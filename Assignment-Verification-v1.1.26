// Airtable verification script for EntryID assignment
// Updated for: Pas de Deux -> Duo/Trio -> Ensemble contiguous numbering
// and "e" suffix for DCG Category == "Ensemble Division".

let table = base.getTable("Chicago 25-26"); // <-- change if needed
let query = await table.selectRecordsAsync({
  fields: [
    "Participant",
    "RoutineType",
    "Sex",
    "AgeDivision",
    "EntryID",
    "DCG ID",
    "RoutineTitle",
    "#Dancers",
    "Age",
    "Date of Birth",
    "DCG Category"
  ]
});

// ----- helpers -----
const countParticipants = (p) => (p || "").split(",").map(s => s.trim()).filter(Boolean).length;

function parseEntryId(s) {
  if (!s) return null;
  // supports:
  //  - 123
  //  - 123.2
  //  - 123c, 123xc, 123.2c, 123.2xc
  //  - 123e   (group "Ensemble Division" suffix)
  const m = String(s).trim().match(/^(\d+)(?:\.(\d+))?((?:xc)|c|e)?$/i);
  if (!m) return null;
  return {
    base: Number(m[1]),
    ord: m[2] ? Number(m[2]) : null,        // null => no ".N"
    tag: m[3] ? m[3].toLowerCase() : ""     // "", "c", "xc", or "e"
  };
}

function nOrInf(v, inf = Number.POSITIVE_INFINITY) {
  if (typeof v === "number") return v;
  const n = parseInt(v, 10);
  return Number.isFinite(n) ? n : inf;
}

function contiguousCheck(basesArr) {
  if (!basesArr.length) return true;
  const sorted = [...new Set(basesArr)].sort((a,b)=>a-b);
  const minB = sorted[0], maxB = sorted[sorted.length-1];
  return (maxB - minB + 1 === sorted.length);
}

function minMaxFromSet(s) {
  if (!s || s.size === 0) return {min: null, max: null};
  const arr = [...s].sort((a,b)=>a-b);
  return {min: arr[0], max: arr[arr.length-1]};
}

function ageNumberFromText(rec) {
  const raw = rec.getCellValue("Age");
  if (raw === null || raw === undefined || raw === "") return Number.POSITIVE_INFINITY;
  const n = parseFloat(String(raw).trim());
  return isNaN(n) ? Number.POSITIVE_INFINITY : n;
}

function parseDOBStringToDate(dobText) {
  if (!dobText) return null;
  const s = String(dobText).replace(/[()]/g, "").trim();
  const m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
  if (!m) return null;
  const mm = parseInt(m[1], 10), dd = parseInt(m[2], 10), yyyy = parseInt(m[3], 10);
  const d = new Date(yyyy, mm - 1, dd);
  return isNaN(d.getTime()) ? null : d;
}

function avgDobTimestampFromDOBList(rec) {
  const raw = rec.getCellValue("Date of Birth");
  if (!raw) return null;

  const parts = String(raw).split(",").map(s => s.trim()).filter(Boolean);
  let sum = 0, count = 0;

  for (const part of parts) {
    const d = parseDOBStringToDate(part);
    if (d) { sum += d.getTime(); count++; }
  }
  return count > 0 ? (sum / count) : null;
}

function groupType(rec) {
  const dancersRaw = rec.getCellValue("#Dancers");
  const n = parseInt(String(dancersRaw ?? "").trim(), 10);
  const dancers = isNaN(n) ? 999 : n;

  const title = String(rec.getCellValue("RoutineTitle") ?? "").trim();
  const hasPas = title.includes("PAS DE DEUX");

  if (dancers === 2 && hasPas) return "Pas de Deux";
  if ((dancers === 2 || dancers === 3) && !hasPas) return "Duo/Trio";
  if (dancers >= 4) return "Ensemble";

  // failsafe: treat unknowns as Ensemble (keeps them last)
  return "Ensemble";
}

function needsESuffix(rec) {
  const v = rec.getCellValue("DCG Category");
  return String(v ?? "").trim() === "Ensemble Division";
}

function participantsList(rec) {
  return (rec.getCellValue("Participant") || "")
    .split(",")
    .map(s => s.trim())
    .filter(Boolean);
}

function intersects(aList, bSet) {
  for (const x of aList) if (bSet.has(x)) return true;
  return false;
}

// ----- collect / classify -----
const issues = [];
const warnings = [];

const allRecords = query.records.filter(r => r.getCellValue("EntryID")); // only those with IDs
const entryIdStrings = new Set();

const solos = [];        // solo records (Classical/Contemporary)
const groups = [];       // all non-solo records (including Pas/Duo/Trio/Ensemble)

// Track duplicates on the full EntryID string
for (const r of allRecords) {
  const eid = r.getCellValue("EntryID");
  if (entryIdStrings.has(eid)) issues.push(`Duplicate EntryID string found: ${eid}`);
  entryIdStrings.add(eid);

  const pCount = countParticipants(r.getCellValue("Participant") || "");
  if (pCount === 1) solos.push(r);
  else groups.push(r);
}

// ----- solos grouped by participant -----
const byParticipant = new Map();
for (const r of solos) {
  const name = (r.getCellValue("Participant") || "").trim();
  if (!byParticipant.has(name)) byParticipant.set(name, []);
  byParticipant.get(name).push(r);
}

// For solo bucket accounting, we need one base per participant per division.
const participantBaseInt = new Map(); // participant -> base (solo)
const participantDivisions = new Map(); // participant -> Set(divisions seen)
const soloBaseByDivision = {
  Primary: new Set(),
  Junior: new Set(),
  Senior: new Set()
};

// For edge printing: base -> participants per division
const soloBaseToParticipantsByDivision = {
  Primary: new Map(),
  Junior: new Map(),
  Senior: new Map()
};

function addSoloEdge(div, base, participant) {
  if (!soloBaseToParticipantsByDivision[div].has(base)) {
    soloBaseToParticipantsByDivision[div].set(base, new Set());
  }
  soloBaseToParticipantsByDivision[div].get(base).add(participant);
}

// Per-participant deep checks (tags, suffixes, DCG order, base consistency)
for (const [participant, records] of byParticipant.entries()) {
  const parsed = [];
  const divisionsSeen = new Set();

  for (const r of records) {
    const eid = r.getCellValue("EntryID");
    const pi = parseEntryId(eid);
    if (!pi) {
      issues.push(`Invalid EntryID format on solo: "${eid}" (record ${r.id})`);
      continue;
    }

    // solos should NEVER have tag "e"
    if (pi.tag === "e") {
      issues.push(`Solo EntryID should not have "e" suffix: "${eid}" (record ${r.id})`);
    }

    parsed.push({
      r, eid, pi,
      type: r.getCellValue("RoutineType"),
      dcg: nOrInf(r.getCellValue("DCG ID")),
      div: r.getCellValue("AgeDivision") || "N/A",
      sex: r.getCellValue("Sex") || "N/A"
    });
    divisionsSeen.add(r.getCellValue("AgeDivision") || "N/A");
  }

  if (!parsed.length) continue;

  // base integer must be consistent for the participant
  const baseSet = new Set(parsed.map(x => x.pi.base));
  if (baseSet.size !== 1) {
    issues.push(`Participant "${participant}" has multiple base integers: ${[...baseSet].join(", ")}`);
  }
  const base = parsed[0].pi.base;
  participantBaseInt.set(participant, base);
  participantDivisions.set(participant, divisionsSeen);

  // If participant appears in multiple divisions, flag
  if (divisionsSeen.size > 1) {
    issues.push(`Participant "${participant}" appears in multiple divisions: ${[...divisionsSeen].join(", ")}`);
  }

  // Attribute this participant to its division(s) for bucket contiguity/gap checks & edge print
  for (const div of divisionsSeen) {
    if (soloBaseByDivision[div]) {
      soloBaseByDivision[div].add(base);
      addSoloEdge(div, base, participant);
    }
  }

  // Suffix/tag checks by type with DCG ordering
  const classical = parsed.filter(x => x.type === "Classical").sort((a,b)=>a.dcg - b.dcg);
  const contemporary = parsed.filter(x => x.type === "Contemporary").sort((a,b)=>a.dcg - b.dcg);

  // CLASSICAL: tag must be "", suffix "", ".2", ".3", ...
  classical.forEach((x, i) => {
    if (x.pi.tag !== "") {
      issues.push(`Classical routine has tag "${x.pi.tag}" (should be none): ${participant}, EntryID ${x.eid}`);
    }
    const expectedOrd = (i === 0) ? null : (i + 1);
    if ((expectedOrd === null && x.pi.ord !== null) ||
        (expectedOrd !== null && x.pi.ord !== expectedOrd)) {
      issues.push(`Classical suffix mismatch for ${participant}: expected ${i===0?'no suffix':'.'+expectedOrd}, got "${x.eid}" (DCG ${x.dcg})`);
    }
  });

  // CONTEMPORARY: tag "c" if any Classical exists; else "xc". Suffix increments by DCG order.
  const expectTag = classical.length > 0 ? "c" : "xc";
  if (contemporary.length > 0) {
    const tagsUsed = new Set(contemporary.map(x => x.pi.tag));
    if (tagsUsed.size !== 1 || !tagsUsed.has(expectTag)) {
      issues.push(`Contemporary tag inconsistency for ${participant}: expected "${expectTag}" only, saw [${[...tagsUsed].join(", ")}]`);
    }
    contemporary.forEach((x, i) => {
      if (x.pi.tag !== expectTag) {
        issues.push(`Contemporary tag mismatch for ${participant}: expected "${expectTag}", got "${x.pi.tag}" in ${x.eid}`);
      }
      const expectedOrd = (i === 0) ? null : (i + 1);
      if ((expectedOrd === null && x.pi.ord !== null) ||
          (expectedOrd !== null && x.pi.ord !== expectedOrd)) {
        issues.push(`Contemporary suffix mismatch for ${participant}: expected ${i===0?expectTag:'.'+expectedOrd+expectTag}, got "${x.eid}" (DCG ${x.dcg})`);
      }
    });
  }
}

// ----- sex order per solo division: female before male -----
const divisions = ["Primary","Junior","Senior"];
for (const div of divisions) {
  const femaleBases = [];
  const maleBases = [];
  for (const [p, records] of byParticipant.entries()) {
    const inDiv = records.filter(r => r.getCellValue("AgeDivision") === div);
    if (inDiv.length === 0) continue;
    const base = participantBaseInt.get(p);
    const sex = (inDiv[0].getCellValue("Sex") || "N/A");
    if (sex === "Female") femaleBases.push(base);
    else if (sex === "Male") maleBases.push(base);
  }
  if (femaleBases.length && maleBases.length) {
    const maxF = Math.max(...femaleBases);
    const minM = Math.min(...maleBases);
    if (!(minM > maxF)) {
      issues.push(`Sex order violation in ${div}: min male base (${minM}) is not > max female base (${maxF}).`);
    }
  }
}

// ----- bucket building (UPDATED) -----
const bucketBases = {
  Primary: soloBaseByDivision.Primary,
  Junior: soloBaseByDivision.Junior,
  Senior: soloBaseByDivision.Senior,
  PasDeDeux: new Set(),
  DuoTrio: new Set(),
  Ensemble: new Set()
};

// For edge printing on groups: base -> participants string(s)
const pasBaseToParticipants = new Map();
const duoBaseToParticipants = new Map();
const ensBaseToParticipants = new Map();

function addNameToMap(map, base, name) {
  if (!map.has(base)) map.set(base, new Set());
  map.get(base).add(name);
}

// Group records: validate formatting rules + collect bases by groupType
// Also validate required "e" suffix rule for Ensemble Division.
for (const r of groups) {
  const eid = r.getCellValue("EntryID");
  const pi = parseEntryId(eid);
  if (!pi) {
    issues.push(`Invalid EntryID on group record: "${eid}" (record ${r.id})`);
    continue;
  }

  // Groups should not have ".N" suffix; only plain integer, optionally + "e"
  if (pi.ord !== null) {
    issues.push(`Group EntryID should not have ".N" suffix: "${eid}" (record ${r.id})`);
  }

  // Groups should not have "c" / "xc" tags
  if (pi.tag === "c" || pi.tag === "xc") {
    issues.push(`Group EntryID should not have "c/xc" tag: "${eid}" (record ${r.id})`);
  }

  // Enforce Ensemble Division -> must have 'e'
  const shouldHaveE = needsESuffix(r);
  if (shouldHaveE && pi.tag !== "e") {
    issues.push(`Missing "e" suffix: DCG Category is "Ensemble Division" but EntryID is "${eid}" (record ${r.id})`);
  }
  if (!shouldHaveE && pi.tag === "e") {
    issues.push(`Unexpected "e" suffix: DCG Category is not "Ensemble Division" but EntryID is "${eid}" (record ${r.id})`);
  }

  const gt = groupType(r);
  if (gt === "Pas de Deux") {
    bucketBases.PasDeDeux.add(pi.base);
    addNameToMap(pasBaseToParticipants, pi.base, r.getCellValue("Participant") || "(no participant)");
  } else if (gt === "Duo/Trio") {
    bucketBases.DuoTrio.add(pi.base);
    addNameToMap(duoBaseToParticipants, pi.base, r.getCellValue("Participant") || "(no participant)");
  } else {
    bucketBases.Ensemble.add(pi.base);
    addNameToMap(ensBaseToParticipants, pi.base, r.getCellValue("Participant") || "(no participant)");
  }
}

// Build global base -> buckets map (helps detect any gap pollution)
const baseToBuckets = new Map(); // base -> Set(bucketNames)
for (const [bucket, set] of Object.entries(bucketBases)) {
  for (const b of set) {
    if (!baseToBuckets.has(b)) baseToBuckets.set(b, new Set());
    baseToBuckets.get(b).add(bucket);
  }
}

// ----- contiguity inside each bucket -----
for (const [bucket, set] of Object.entries(bucketBases)) {
  const arr = [...set];
  if (!contiguousCheck(arr)) {
    const sorted = [...new Set(arr)].sort((a,b)=>a-b);
    const minB = sorted[0], maxB = sorted[sorted.length-1];
    issues.push(`Non-contiguous bases within ${bucket}. min=${minB}, max=${maxB}, uniqueCount=${sorted.length}, expected=${maxB - minB + 1}`);
  }
}

// ----- verify gaps BETWEEN BUCKETS (UPDATED RULES) -----
// 5-number gaps only between: Primary->Junior, Junior->Senior, Senior->PasDeDeux
// NO gaps between PasDeDeux->DuoTrio->Ensemble (they should be contiguous).

const bucketOrder = ["Primary","Junior","Senior","PasDeDeux","DuoTrio","Ensemble"];
const presentBuckets = bucketOrder.filter(b => bucketBases[b] && bucketBases[b].size > 0);

function requireGap(prev, next) {
  return (prev === "Primary" && next === "Junior") ||
         (prev === "Junior"  && next === "Senior") ||
         (prev === "Senior"  && next === "PasDeDeux");
}

function requireContiguous(prev, next) {
  return (prev === "PasDeDeux" && next === "DuoTrio") ||
         (prev === "DuoTrio"  && next === "Ensemble");
}

for (let i = 0; i < presentBuckets.length - 1; i++) {
  const prev = presentBuckets[i];
  const next = presentBuckets[i+1];
  const {max: prevMax} = minMaxFromSet(bucketBases[prev]);
  const {min: nextMin} = minMaxFromSet(bucketBases[next]);
  if (prevMax === null || nextMin === null) continue;

  if (requireGap(prev, next)) {
    const expectedNextMin = prevMax + 6; // skip 5 integers
    if (nextMin !== expectedNextMin) {
      issues.push(`Gap error between ${prev} → ${next}: expected next min base ${expectedNextMin} (5-number gap), got ${nextMin}.`);
    }
    // Ensure gap numbers are unused anywhere
    for (let g = prevMax + 1; g <= prevMax + 5; g++) {
      if (baseToBuckets.has(g)) {
        issues.push(`Gap violation: base ${g} (should be empty between ${prev} and ${next}) is used in bucket(s): ${[...baseToBuckets.get(g)].join(", ")}`);
      }
    }
  } else if (requireContiguous(prev, next)) {
    const expectedNextMin = prevMax + 1; // contiguous
    if (nextMin !== expectedNextMin) {
      issues.push(`Contiguity error between ${prev} → ${next}: expected next min base ${expectedNextMin} (contiguous), got ${nextMin}.`);
    }
  }
}

// ----- verify type block ordering (strong check) -----
const {max: pasMax} = minMaxFromSet(bucketBases.PasDeDeux);
const {min: duoMin} = minMaxFromSet(bucketBases.DuoTrio);
const {max: duoMax} = minMaxFromSet(bucketBases.DuoTrio);
const {min: ensMin} = minMaxFromSet(bucketBases.Ensemble);

if (pasMax !== null && duoMin !== null && !(duoMin > pasMax)) {
  issues.push(`Type ordering violation: Duo/Trio min base (${duoMin}) is not > Pas de Deux max base (${pasMax}).`);
}
if (duoMax !== null && ensMin !== null && !(ensMin > duoMax)) {
  issues.push(`Type ordering violation: Ensemble min base (${ensMin}) is not > Duo/Trio max base (${duoMax}).`);
}

// ----- optional: warn if immediate participant repeats still occur across group IDs -----
const groupRecordsWithParsed = [];
for (const r of groups) {
  const pi = parseEntryId(r.getCellValue("EntryID"));
  if (!pi) continue;
  groupRecordsWithParsed.push({ r, base: pi.base, pList: participantsList(r), type: groupType(r) });
}
groupRecordsWithParsed.sort((a,b)=>a.base - b.base);

let lastSet = new Set();
for (let i = 0; i < groupRecordsWithParsed.length; i++) {
  const cur = groupRecordsWithParsed[i];
  if (i > 0) {
    if (intersects(cur.pList, lastSet)) {
      warnings.push(
        `Immediate-repeat warning: base ${groupRecordsWithParsed[i-1].base} (${groupRecordsWithParsed[i-1].type}) and base ${cur.base} (${cur.type}) share participant(s).`
      );
    }
  }
  lastSet = new Set(cur.pList);
}

// ----- report -----
function namesForSoloBase(div, base) {
  const m = soloBaseToParticipantsByDivision[div];
  if (!m || !m.has(base)) return [];
  return [...m.get(base)];
}
function namesForBase(map, base) {
  return map.has(base) ? [...map.get(base)] : [];
}

console.log("=== ENTRYID VERIFICATION SUMMARY (updated: Pas/Duo/Ensemble contiguous + 'e' suffix) ===");
console.log(`Total records verified: ${allRecords.length}`);
console.log(`Unique EntryID strings: ${entryIdStrings.size}`);

for (const b of bucketOrder) {
  const set = bucketBases[b];
  const {min, max} = minMaxFromSet(set);
  const count = set.size;
  if (!count) {
    console.log(`${b}: count=0`);
    continue;
  }

  let minNames = [], maxNames = [];
  if (b === "Primary" || b === "Junior" || b === "Senior") {
    minNames = namesForSoloBase(b, min);
    maxNames = namesForSoloBase(b, max);
  } else if (b === "PasDeDeux") {
    minNames = namesForBase(pasBaseToParticipants, min);
    maxNames = namesForBase(pasBaseToParticipants, max);
  } else if (b === "DuoTrio") {
    minNames = namesForBase(duoBaseToParticipants, min);
    maxNames = namesForBase(duoBaseToParticipants, max);
  } else if (b === "Ensemble") {
    minNames = namesForBase(ensBaseToParticipants, min);
    maxNames = namesForBase(ensBaseToParticipants, max);
  }

  console.log(`${b}: count=${count} (min=${min}, max=${max})`);
  console.log(`  ↳ min edge participants: ${minNames.length ? minNames.join(" | ") : "(none found)"}`);
  console.log(`  ↳ max edge participants: ${maxNames.length ? maxNames.join(" | ") : "(none found)"}`);
}

console.log(`Issues found: ${issues.length}`);
if (issues.length) {
  console.log("---- Issues ----");
  issues.forEach((msg, i) => console.log(`${i+1}. ${msg}`));
} else {
  console.log("All checks passed ✅");
}

console.log(`Warnings (non-fatal) found: ${warnings.length}`);
if (warnings.length) {
  console.log("---- Warnings ----");
  warnings.forEach((msg, i) => console.log(`${i+1}. ${msg}`));
}
