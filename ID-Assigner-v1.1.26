// Airtable script to assign EntryIDs to routine entries

let table = base.getTable("Toronto 25-26"); // Change to the correct table name
let query = await table.selectRecordsAsync({
    fields: [
        "Participant",
        "Age",
        "Sex",
        "RoutineType",
        "AgeDivision",
        "StudioName",
        "Date of Birth",   // solos: single DOB text; groups: comma-separated DOBs
        "DCG ID",          // used to order multiple routines per participant
        "RoutineTitle",    // CAPS from DCG
        "#Dancers",        // single line text (number stored as text)
        "DCG Category"     // single line text, may contain "Ensemble Division"
    ]
});

// ---------- Helpers ----------
const divisionOrder = { "Primary": 0, "Junior": 1, "Senior": 2 };

function participantsCountFromField(rec) {
    const p = rec.getCellValue("Participant");
    if (!p) return 0;
    return p.split(",").map(s => s.trim()).filter(Boolean).length || 0;
}
function isSolo(rec) {
    return participantsCountFromField(rec) === 1;
}

// Parse one DOB token like "12/26/2016" or "(12/26/2016)" to Date
function parseDOBStringToDate(dobText) {
    if (!dobText) return null;
    const s = String(dobText).replace(/[()]/g, "").trim();
    const m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
    if (!m) return null;
    const mm = parseInt(m[1], 10), dd = parseInt(m[2], 10), yyyy = parseInt(m[3], 10);
    const d = new Date(yyyy, mm - 1, dd);
    return isNaN(d.getTime()) ? null : d;
}

// For solo ordering (single DOB in field)
function parseDOBTextToDate(rec) {
    return parseDOBStringToDate(rec.getCellValue("Date of Birth"));
}
function dobTimestamp(rec) {
    const d = parseDOBTextToDate(rec);
    return d ? d.getTime() : null;
}

// For group tie-break: compute average DOB timestamp from comma-separated DOBs in {Date of Birth}
function avgDobTimestampFromDOBList(rec) {
    const raw = rec.getCellValue("Date of Birth");
    if (!raw) return null;

    const parts = String(raw).split(",").map(s => s.trim()).filter(Boolean);
    let sum = 0;
    let count = 0;

    for (const part of parts) {
        const d = parseDOBStringToDate(part);
        if (d) {
            sum += d.getTime();
            count++;
        }
    }
    return count > 0 ? (sum / count) : null;
}

function dcgValue(rec) {
    const v = rec.getCellValue("DCG ID");
    if (typeof v === "number") return v;
    const n = parseInt(v, 10);
    return isNaN(n) ? Number.POSITIVE_INFINITY : n;
}

// Parse Age (stored as single line text) to number
function ageNumber(rec) {
    const raw = rec.getCellValue("Age");
    if (raw === null || raw === undefined || raw === "") return Number.POSITIVE_INFINITY;
    const n = parseFloat(String(raw).trim());
    return isNaN(n) ? Number.POSITIVE_INFINITY : n;
}

// Sort overall (solos):
// - AgeDivision: Primary -> Junior -> Senior
// - For solos only: DOB (youngest -> oldest = later DOB first)
// - For non-solos: Age ascending
// - Females before Males; stable tie-break on participant name
function sortRecords(records) {
    const sexOrder = { "Female": 0, "Male": 1, "N/A": 2 };
    return records.sort((a, b) => {
        const divA = divisionOrder[a.getCellValue("AgeDivision")] ?? 999;
        const divB = divisionOrder[b.getCellValue("AgeDivision")] ?? 999;
        if (divA !== divB) return divA - divB;

        const aSolo = isSolo(a);
        const bSolo = isSolo(b);

        if (aSolo && bSolo) {
            const ta = dobTimestamp(a);
            const tb = dobTimestamp(b);
            if (ta !== tb) {
                const aa = (ta === null) ? -Infinity : ta; // missing DOB = oldest
                const bb = (tb === null) ? -Infinity : tb;
                return bb - aa; // DESC (later DOB = younger first)
            }
        } else if (!aSolo && !bSolo) {
            const ageA = ageNumber(a);
            const ageB = ageNumber(b);
            if (ageA !== ageB) return ageA - ageB; // ASC (youngest first)
        } else {
            if (aSolo !== bSolo) return aSolo ? -1 : 1;
        }

        const sa = sexOrder[a.getCellValue("Sex") || "N/A"];
        const sb = sexOrder[b.getCellValue("Sex") || "N/A"];
        if (sa !== sb) return sa - sb;

        const pa = (a.getCellValue("Participant") || "").toLowerCase();
        const pb = (b.getCellValue("Participant") || "").toLowerCase();
        return pa.localeCompare(pb);
    });
}

// Preserve participant order from the sorted list,
// but within each participant group, sort by DCG ID ASC
function groupSortByParticipantDCG(records) {
    const groups = new Map();
    const order = [];
    for (const r of records) {
        const p = r.getCellValue("Participant") || "";
        if (!groups.has(p)) {
            groups.set(p, []);
            order.push(p);
        }
        groups.get(p).push(r);
    }
    for (const p of order) {
        groups.get(p).sort((a, b) => dcgValue(a) - dcgValue(b));
    }
    const out = [];
    for (const p of order) out.push(...groups.get(p));
    return out;
}

// ---------- Main (SOLOS) ----------
let baseEntryId = 555; // Change to starting number for Primary at that city
let lastAssignedId = baseEntryId - 1;
let updates = [];
let participantRoutineCount = new Map();

let allRecords = query.records.filter(
    record => record.getCellValue("RoutineType") !== "N/A"
);

// Global ordering (incl. DOB for solos)
let sortedRecords = sortRecords(allRecords);
let ageDivisions = ["Primary", "Junior", "Senior"];

for (let division of ageDivisions) {
    let divisionRecords = sortedRecords.filter(r => r.getCellValue("AgeDivision") === division);

    // Solo buckets only (ensembles handled later)
    let femaleClassical = groupSortByParticipantDCG(
        divisionRecords.filter(r =>
            r.getCellValue("RoutineType") === "Classical" &&
            r.getCellValue("Sex") === "Female" &&
            isSolo(r)
        )
    );
    let femaleContemporary = groupSortByParticipantDCG(
        divisionRecords.filter(r =>
            r.getCellValue("RoutineType") === "Contemporary" &&
            r.getCellValue("Sex") === "Female" &&
            isSolo(r)
        )
    );
    let maleClassical = groupSortByParticipantDCG(
        divisionRecords.filter(r =>
            r.getCellValue("RoutineType") === "Classical" &&
            r.getCellValue("Sex") === "Male" &&
            isSolo(r)
        )
    );
    let maleContemporary = groupSortByParticipantDCG(
        divisionRecords.filter(r =>
            r.getCellValue("RoutineType") === "Contemporary" &&
            r.getCellValue("Sex") === "Male" &&
            isSolo(r)
        )
    );

    // ---- FEMALE / CLASSICAL ----
    for (let record of femaleClassical) {
        const participant = record.getCellValue("Participant");
        if (!participantRoutineCount.has(participant)) {
            participantRoutineCount.set(participant, { EntryID: null, Classical: 0, Contemporary: 0 });
        }
        const routineCounts = participantRoutineCount.get(participant);
        if (routineCounts.EntryID === null) {
            lastAssignedId++;
            routineCounts.EntryID = lastAssignedId;
        }
        routineCounts.Classical++;
        const suffix = routineCounts.Classical > 1 ? `.${routineCounts.Classical}` : "";
        updates.push({ id: record.id, fields: { EntryID: `${routineCounts.EntryID}${suffix}` } });
    }

    // ---- FEMALE / CONTEMPORARY ----
    for (let record of femaleContemporary) {
        const participant = record.getCellValue("Participant");
        if (!participantRoutineCount.has(participant)) {
            participantRoutineCount.set(participant, { EntryID: null, Classical: 0, Contemporary: 0 });
        }
        const routineCounts = participantRoutineCount.get(participant);
        let entryId = routineCounts.EntryID || null;
        let suffix = "";

        if (routineCounts.Classical > 0) {
            routineCounts.Contemporary++;
            suffix = routineCounts.Contemporary > 1 ? `.${routineCounts.Contemporary}c` : "c";
        } else {
            if (entryId === null) {
                lastAssignedId++;
                entryId = lastAssignedId;
                routineCounts.EntryID = entryId;
            }
            routineCounts.Contemporary++;
            suffix = routineCounts.Contemporary > 1 ? `.${routineCounts.Contemporary}xc` : "xc";
        }

        updates.push({ id: record.id, fields: { EntryID: `${routineCounts.EntryID}${suffix}` } });
    }

    // ---- MALE / CLASSICAL ----
    for (let record of maleClassical) {
        const participant = record.getCellValue("Participant");
        if (!participantRoutineCount.has(participant)) {
            participantRoutineCount.set(participant, { EntryID: null, Classical: 0, Contemporary: 0 });
        }
        const routineCounts = participantRoutineCount.get(participant);
        if (routineCounts.EntryID === null) {
            lastAssignedId++;
            routineCounts.EntryID = lastAssignedId;
        }
        routineCounts.Classical++;
        const suffix = routineCounts.Classical > 1 ? `.${routineCounts.Classical}` : "";
        updates.push({ id: record.id, fields: { EntryID: `${routineCounts.EntryID}${suffix}` } });
    }

    // ---- MALE / CONTEMPORARY ----
    for (let record of maleContemporary) {
        const participant = record.getCellValue("Participant");
        if (!participantRoutineCount.has(participant)) {
            participantRoutineCount.set(participant, { EntryID: null, Classical: 0, Contemporary: 0 });
        }
        const routineCounts = participantRoutineCount.get(participant);
        let entryId = routineCounts.EntryID || null;
        let suffix = "";

        if (routineCounts.Classical > 0) {
            routineCounts.Contemporary++;
            suffix = routineCounts.Contemporary > 1 ? `.${routineCounts.Contemporary}c` : "c";
        } else {
            if (entryId === null) {
                lastAssignedId++;
                entryId = lastAssignedId;
                routineCounts.EntryID = entryId;
            }
            routineCounts.Contemporary++;
            suffix = routineCounts.Contemporary > 1 ? `.${routineCounts.Contemporary}xc` : "xc";
        }

        updates.push({ id: record.id, fields: { EntryID: `${routineCounts.EntryID}${suffix}` } });
    }

    // ----- GAP: skip 5 integers after finishing MALES for this division -----
    // This also creates the required gap between last Senior soloist and first Pas de Deux.
    lastAssignedId += 5;
}

// Perform batched updates for solos
while (updates.length > 0) {
    await table.updateRecordsAsync(updates.splice(0, 50));
}

// ---------- Pas de Deux / Duo-Trios / Ensembles (NEW RULES) ----------

// Reset updates array for group routines
updates = [];

// Determine group type using {#Dancers} + {RoutineTitle}
function groupType(rec) {
    const dancersRaw = rec.getCellValue("#Dancers");
    const n = parseInt(String(dancersRaw ?? "").trim(), 10);
    const dancers = isNaN(n) ? 999 : n;

    const title = String(rec.getCellValue("RoutineTitle") ?? "").trim();
    const hasPas = title.includes("PAS DE DEUX"); // titles are CAPS from DCG

    if (dancers === 2 && hasPas) return "Pas de Deux";
    if ((dancers === 2 || dancers === 3) && !hasPas) return "Duo/Trio";
    if (dancers >= 4) return "Ensemble";

    // Failsafe: if weird/missing values, treat as Ensemble (keeps it last)
    return "Ensemble";
}

const typeOrder = { "Pas de Deux": 0, "Duo/Trio": 1, "Ensemble": 2 };

function participantsList(rec) {
    return (rec.getCellValue("Participant") || "")
        .split(",")
        .map(s => s.trim())
        .filter(Boolean);
}

function intersects(aList, bSet) {
    for (const x of aList) {
        if (bSet.has(x)) return true;
    }
    return false;
}

// Sort inside a type: youngest -> oldest by {Age} ASC.
// If Age tie, use avg DOB timestamp DESC (later DOB = younger).
function sortGroupList(list) {
    return list.sort((a, b) => {
        const aa = ageNumber(a);
        const bb = ageNumber(b);
        if (aa !== bb) return aa - bb; // youngest first

        const ta = avgDobTimestampFromDOBList(a);
        const tb = avgDobTimestampFromDOBList(b);
        const aT = (ta === null) ? -Infinity : ta;
        const bT = (tb === null) ? -Infinity : tb;
        if (aT !== bT) return bT - aT; // later avg DOB first (younger first)

        const pa = (a.getCellValue("Participant") || "").toLowerCase();
        const pb = (b.getCellValue("Participant") || "").toLowerCase();
        return pa.localeCompare(pb);
    });
}

// Reorder (greedy) to avoid immediate participant repeats WITHOUT skipping IDs.
// Does NOT cross type boundaries because you call it per-type.
function reorderAvoidImmediateRepeats(sortedList, lastParticipantSet) {
    const remaining = [...sortedList];
    const out = [];

    while (remaining.length > 0) {
        let pickIndex = -1;

        // Find first record that doesn't share a participant with previous routine
        for (let i = 0; i < remaining.length; i++) {
            const pList = participantsList(remaining[i]);
            if (!intersects(pList, lastParticipantSet)) {
                pickIndex = i;
                break;
            }
        }

        // If none found, take the next in order (failsafe)
        if (pickIndex === -1) pickIndex = 0;

        const rec = remaining.splice(pickIndex, 1)[0];
        out.push(rec);

        // Update lastParticipantSet to exactly the participants of the last assigned routine
        lastParticipantSet.clear();
        for (const p of participantsList(rec)) lastParticipantSet.add(p);
    }

    return out;
}

function needsESuffix(rec) {
    const v = rec.getCellValue("DCG Category");
    return String(v ?? "").trim() === "Ensemble Division";
}

// Collect ONLY non-solo routines that are not N/A.
// (This safely covers anything DCG sends that isn't a solo.)
let groupRecords = allRecords.filter(r => !isSolo(r));

// Partition into types
let pasList = sortGroupList(groupRecords.filter(r => groupType(r) === "Pas de Deux"));
let duoList = sortGroupList(groupRecords.filter(r => groupType(r) === "Duo/Trio"));
let ensList = sortGroupList(groupRecords.filter(r => groupType(r) === "Ensemble"));

// Apply "avoid immediate repeats" reordering within each type,
// but keep type blocks intact (Pas -> Duo -> Ensemble)
let lastParticipantSet = new Set();

pasList = reorderAvoidImmediateRepeats(pasList, lastParticipantSet);
duoList = reorderAvoidImmediateRepeats(duoList, lastParticipantSet);
ensList = reorderAvoidImmediateRepeats(ensList, lastParticipantSet);

// Concatenate in required type order
let finalGroupOrder = [...pasList, ...duoList, ...ensList];

// Assign contiguous IDs (no gaps) starting after the existing post-senior solo gap
for (const rec of finalGroupOrder) {
    lastAssignedId++;

    let idStr = `${lastAssignedId}`;
    if (needsESuffix(rec)) idStr = `${idStr}e`;

    updates.push({ id: rec.id, fields: { EntryID: idStr } });
}

// Perform batched updates for groups
while (updates.length > 0) {
    await table.updateRecordsAsync(updates.splice(0, 50));
}
